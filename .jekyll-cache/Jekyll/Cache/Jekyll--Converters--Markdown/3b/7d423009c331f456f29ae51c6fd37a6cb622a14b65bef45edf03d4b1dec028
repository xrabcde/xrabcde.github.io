I"H(<ul>
  <li>디스크 : 컴퓨터 시스템의 대표적인 2차 저장장치, 메모리와 달리 <strong>비휘발성</strong>
    <h2 id="디스크의-구조">디스크의 구조</h2>
  </li>
  <li>디스크는 <code class="language-plaintext highlighter-rouge">논리블록</code>(일정한 크기의 저장공간)들로 이루어진 1차원 배열</li>
  <li>데이터가 저장될 때에도 <code class="language-plaintext highlighter-rouge">논리블록</code> 단위로 저장되고, 입출력이 일어날 때도 <code class="language-plaintext highlighter-rouge">논리블록</code> 단위로 전송됨</li>
  <li>각 논리블록이 저장되는 디스크내의 물리적 위치를 <code class="language-plaintext highlighter-rouge">섹터</code>라고 부름 (논리블록 하나가 섹터 하나와 1대1 매핑)</li>
  <li>디스크의 물리적 구조 &gt; 마그네틱 원판 (한 개 혹은 여러 개) &gt; 트랙 &gt; 섹터(최소한의 단위 정보 저장)</li>
  <li><code class="language-plaintext highlighter-rouge">실린더</code> : 여러 개의 원판에서 상대적 위치가 동일한 트랙들의 집합</li>
  <li><code class="language-plaintext highlighter-rouge">암</code> : 데이터를 읽고 쓰기 위해 해당 섹터가 위치한 실린더로 이동해서 원판이 회전하며 해당 섹터위치에 도달</li>
</ul>

<div style="width:60% !important; margin:0 auto">
<img src="/assets/img/os9-1.png" alt="os9-1.png" />
</div>

<h2 id="디스크-스케줄링">디스크 스케줄링</h2>
<ul>
  <li>디스크에 대한 접근시간 = 탐색시간 + 회전지연시간 + 전송시간
    <ol>
      <li><strong>탐색시간</strong> : 디스크 헤드를 해당 실린더 위치로 이동시키는 데 걸리는 시간</li>
      <li>회전지연시간 : 디스크가 회전해서 읽고 쓰려는 섹터가 헤드 위치에 도달하기까지 걸리는 시간</li>
      <li>전송시간 : 해당 섹터가 헤드 위치에 도달한 후 데이터를 실제로 섹터에 읽고 쓰는 데 소요되는 시간</li>
    </ol>
  </li>
  <li>디스크 입출력 효율을 높이기 위해서는 디스크 접근시간을 최소화해야 함 (BUT 회전지연시간과 전송시간은 수치도 작고 통제하기 힘듦 ⇒ <strong>탐색시간을 최소화!</strong>)</li>
  <li><strong>디스크 스케줄링</strong> : 여러 섹터들에 대한 입출력 요청이 들어왔을 때 어떤 순서로 처리할 것인지 결정하는 매커니즘 ⇒ <strong>디스크 헤드의 이동거리를 줄이는 것이 목표!</strong></li>
</ul>

<h3 id="1-fcfs-스케줄링-first-come-first-served">1. FCFS 스케줄링 (First Come First Served)</h3>
<ul>
  <li>먼저 들어온 요청 먼저 처리</li>
</ul>

<blockquote>
  <p>실린더 위치 : 0-199, 현재 헤드 : 54, 요청 : <strong>99 184 36 123 15 125 66 68</strong></p>
</blockquote>

<ul>
  <li>디스크 헤드가 54번 실린더에서 출발해 99 &gt; 184 &gt; 36 &gt; … 순으로 이동</li>
  <li>총 헤드의 이동거리 : 644</li>
</ul>

<div style="width:60% !important; margin:0 auto">
<img src="/assets/img/os9-2.png" alt="os9-2.png" />
</div>

<ul>
  <li>ex. 은행창구, 매표소</li>
  <li>❌ 디스크 헤드가 움직이면서 서비스를 해야하므로 효율성이 매우 떨어짐</li>
</ul>

<h3 id="2-sstf-스케줄링-shortest-seek-time-first">2. SSTF 스케줄링 (Shortest Seek Time First)</h3>
<ul>
  <li>현재 위치로부터 가장 가까운 위치에 있는 요청을 먼저 처리</li>
</ul>

<blockquote>
  <p>실린더 위치 : 0-199, 현재 헤드 : 54, 요청 : <strong>99 184 36 123 15 125 66 68</strong></p>
</blockquote>

<ul>
  <li>현재 위치 54에서 가장 가까운 66번 요청 먼저 처리 &gt; 68 &gt; 36 &gt; …</li>
  <li>총 헤드의 이동거리 : 236</li>
</ul>

<div style="width:60% !important; margin:0 auto">
<img src="/assets/img/os9-3.png" alt="os9-3.png" />
</div>

<ul>
  <li>✅ 헤드의 이동거리를 줄여 디스크 입출력 효율성 증가</li>
  <li>❌ <code class="language-plaintext highlighter-rouge">기아 현상(starvation)</code> : 현재 위치로부터 가까운 요청이 지속적으로 들어올 경우 멀리 떨어진 곳의 요청은 무한히 기다려야 함</li>
</ul>

<p>⇒ FCFS와 비교해서 헤드의 이동거리를 많이 줄일 수 있지만 가장 우수한 알고리즘은 아님</p>

<h3 id="3-scan-알고리즘">3. SCAN 알고리즘</h3>
<ul>
  <li>헤드가 디스크의 안쪽 끝과 바깥쪽 끝을 오가며 경로에 존재하는 모든 요청 처리</li>
  <li>ex. 버스가 일정 경로에 따라 움직이며 정류장에서 사람들을 태우는 방식</li>
</ul>

<blockquote>
  <p>실린더 위치 : 0-199, 현재 헤드 : 54, 요청 : <strong>99 184 36 123 15 125 66 68</strong></p>
</blockquote>

<ul>
  <li>헤드가 현재 위치 54에서 0번 방향으로 이동중이라면 36 &gt; 15 &gt; 0에서 방향 바꾸고 &gt; 66 &gt; …</li>
  <li>총 헤드의 이동거리 : 238</li>
</ul>

<div style="width:60% !important; margin:0 auto">
<img src="/assets/img/os9-4.png" alt="os9-4.png" />
</div>

<ul>
  <li>ex. 엘리베이터 스케줄링 알고리즘</li>
  <li>✅ FCFS처럼 불필요한 헤드 이동 없음</li>
  <li>✅ SSTF처럼 일부 지역이 지나치게 오래 기다리는 기아 현상 없음</li>
</ul>

<p>⇒ 효율성과 형평성 모두 만족하는 알고리즘</p>

<ul>
  <li>❌ 모든 실린더 위치의 기다리는 시간이 공평하지는 않음 (끝쪽보다 가운데 위치가 기다리는 평균시간이 더 짧음)</li>
</ul>

<h3 id="4-c-scan-알고리즘">4. C-SCAN 알고리즘</h3>
<ul>
  <li>SCAN 알고리즘의 위치에 따른 탐색시간 편차를 보완하기 위해 나온 알고리즘</li>
  <li>SCAN 처럼 한쪽 끝에서 다른쪽 끝으로 이동하는 것은 같지만 <strong>방향을 바꾸지 않고 한방향으로만 움직임</strong></li>
</ul>

<blockquote>
  <p>실린더 위치 : 0-199, 현재 헤드 : 54, 요청 : <strong>99 184 36 123 15 125 66 68</strong></p>
</blockquote>

<ul>
  <li>현재 위치 54에서 199까지 가면서 66 &gt; 68 &gt; 99 &gt; 123 &gt; …</li>
  <li>총 헤드의 이동거리 : 380</li>
</ul>

<div style="width:60% !important; margin:0 auto">
<img src="/assets/img/os9-5.png" alt="os9-5.png" />
</div>

<ul>
  <li>✅ SCAN보다 헤드의 이동거리는 길어지지만 탐색시간의 편차를 줄일 수 있음</li>
</ul>

<h3 id="5-look과-c-look-알고리즘">5. LOOK과 C-LOOK 알고리즘</h3>
<ul>
  <li>요청 존재여부와 관계없이 무조건 한쪽 끝에서 다른쪽 끝까지 이동하는 SCAN 알고리즘과 달리 <strong>그 방향에 더이상 요청이 없으면 방향을 즉시 반대로 바꾸는 방식</strong></li>
  <li>C-LOOK은 C-SCAN과 마찬가지로 한쪽 방향으로만 이동함</li>
</ul>

<blockquote>
  <p>실린더 위치 : 0-199, 현재 헤드 : 54, 요청 : <strong>99 184 36 123 15 125 66 68</strong></p>
</blockquote>

<ul>
  <li>현재 위치 54에서 66 &gt; 68 &gt; … 까지는 SCAN과 동일하지만 184에서 더이상 요청이 없으므로 바로 방향을 바꿈</li>
</ul>

<div style="width:60% !important; margin:0 auto">
<img src="/assets/img/os9-6.png" alt="os9-6.png" />
</div>

<ul>
  <li>✅ 헤드가 반드시 끝까지 이동하는 것이 아니라 요청이 존재하는 가장 낮은 번호까지만 이동하므로 디스크 이동거리 줄일 수 있음</li>
</ul>

<h2 id="다중-디스크-환경에서의-스케줄링">다중 디스크 환경에서의 스케줄링</h2>
<ul>
  <li>수많은 동시 사용자를 서비스하는 서버에서는 동일한 정보를 여러 디스크에 중복 저장함
    <ul>
      <li>✅ 인기 있는 데이터를 여러 디스크로부터 동시에 서비스 가능</li>
      <li>✅ 일부 디스크 오류가 발생해도 지속적 서비스 가능</li>
      <li>✅ 정보의 유실 방지</li>
    </ul>

    <p>⇒ 시스템의 성능과 신뢰성 동시에 향상</p>
  </li>
  <li>하나의 디스크가 아닌 다중 디스크 환경에서 어느 디스크 요청을 처리할지 결정하는 문제
    <ol>
      <li>각 디스크 간의 <strong>부하균형(load balancing)을 이루도록 스케줄링</strong></li>
      <li>전력 소모를 줄이기 위해 일부 디스크에 요청을 집중시키고 나머지는 휴면하도록 스케줄링 (부하편향 기법)</li>
    </ol>
  </li>
</ul>

<h2 id="디스크의-저전력-관리">디스크의 저전력 관리</h2>
<h3 id="1-비활성화-기법">1. 비활성화 기법</h3>
<ul>
  <li>디스크의 상태는 전력소모를 기준으로 크게 네 가지 상태로 구분</li>
</ul>

<ol>
  <li>활동 (active) 상태 : 현재 헤드가 데이터를 읽거나 쓰고 있는 상태</li>
  <li>공회전 (idle) 상태 : 디스크가 회전중이지만 데이터를 읽거나 쓰지는 않는 상태</li>
  <li>준비 (standby) 상태 : 디스크가 회전하지 않지만 인터페이스가 활성화된 상태</li>
  <li>휴면 (sleep) 상태 : 디스크가 회전하지 않고 인터페이스도 비활성화된 상태</li>
</ol>

<p>⇒ 1,2는 활성 상태 / 3,4는 비활성 상태</p>

<ul>
  <li>요청이 없는 경우 디스크를 정지시키는 것이 전력 절감 측면에서 효과적</li>
</ul>

<h3 id="2-회전속도-조절-기법">2. 회전속도 조절 기법</h3>
<ul>
  <li>디스크의 회전속도를 가변적으로 조절하는 기법</li>
</ul>

<h3 id="3-디스크의-데이터-배치-기법">3. 디스크의 데이터 배치 기법</h3>
<ul>
  <li>디스크 내에 데이터의 복제본을 많이 만들어 헤드 위치에서 가까운 복제본에 접근하도록 하는 기법</li>
</ul>

<h3 id="4-버퍼캐싱-및-사전인출-기법">4. 버퍼캐싱 및 사전인출 기법</h3>
<ul>
  <li>디스크가 저전력 모드일 때는 입출력 처리를 최대한 지연시켰다가 정상 전력 모드로 돌아왔을 때 사전인출을 공격적으로 하는 기법</li>
</ul>

<h3 id="5-쓰기전략을-통한-저전력-디스크-기법">5. 쓰기전략을 통한 저전력 디스크 기법</h3>
<ul>
  <li>디스크가 비활성 상태일 때는 쓰기를 하지 않고 기다렸다가, 활성상태로 돌아왔을 때 쓰는 방식</li>
</ul>
:ET