I"D<p>2장에서 <code class="language-plaintext highlighter-rouge">동작 파라미터화</code>를 이용하면 더 유연하고 재사용가능한 코드를 구현할 수 있다는 것을 학습했다.
3장에서는 더 깔끔한 코드를 위해 자바8의 <code class="language-plaintext highlighter-rouge">람다 표현식</code>에 대해 배워보자.</p>
<h2 id="람다란-무엇인가">람다란 무엇인가?</h2>
<p><strong>람다 표현식</strong> 은 메서드로 전달할 수 있는 익명 함수를 단순화한 것이라고 할 수 있다. 람다의 특징을 살펴보자.</p>
<ul>
  <li><strong>익명</strong> : 보통의 메서드와 달리 이름이 없는 <strong>익명</strong> 으로 표현된다.</li>
  <li><strong>함수</strong> : 람다는 메서드처럼 특정 클래스에 종속되지 않으므로 <strong>함수</strong> 라고 부른다.</li>
  <li><strong>전달</strong> : 람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있다.</li>
  <li><strong>간결성</strong> : 익명 클래스처럼 많은 자질구레한 코드를 구현할 필요가 없다.</li>
</ul>

<p>람다를 이용하면 동작 파라미터 형식의 코드를 더 쉽게 구현할 수 있으므로 코드가 간결하고 유연해진다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Comparator&lt;Apple&gt; byWeight = new Comparator&lt;Apple&gt;() {
    public int compare(Apple a1, Apple a2) {
        return a1.getWeight().compareTo(a2.getWeight());
    }
}
</code></pre></div></div>
<p>이 코드에 람다를 적용하면 다음과 같이 바꿀 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Comparator&lt;Apple&gt; byWeight =
        (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());
</code></pre></div></div>
<p>람다는 세 부분으로 이루어진다.</p>
<ul>
  <li><strong>파라미터 리스트</strong> : Comparator의 compare 메서드 파라미터 <code class="language-plaintext highlighter-rouge">(Apple a1, Apple a2)</code></li>
  <li><strong>화살표</strong> : 람다의 파라미터 리스트와 바디를 구분 <code class="language-plaintext highlighter-rouge">-&gt;</code></li>
  <li><strong>람다 바디</strong> : 람다의 반환값에 해당하는 표현식 <code class="language-plaintext highlighter-rouge">a1.getWeight().compareTo(a2.getWeight()</code></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(parameters) -&gt; expression 
(parameters) -&gt; { statements; }
</code></pre></div></div>

<h2 id="어디에-어떻게-람다를-사용하는가">어디에, 어떻게 람다를 사용하는가?</h2>
<h3 id="함수형-인터페이스">함수형 인터페이스</h3>
<p>2장에서 필터 메서드를 파라미터화하기 위해 사용했던 <code class="language-plaintext highlighter-rouge">Predicate&lt;T&gt;</code>가 바로 <strong>함수형 인터페이스</strong> 이다.
함수형 인터페이스는 <strong>정확히 하나의 추상 메서드를 지정하는 인터페이스</strong> 로, Comparator, Runnable 등이 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public interface Predicate&lt;T&gt; {
    boolean test (T t);
}
public interface Comparator&lt;T&gt; {
    int compare (T o1, T o2);
}
public interface Runnable {
    void run();
}
</code></pre></div></div>
<p>람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있으므로 <strong>전체 표현식을 함수형 인터페이스의 인스턴스로 취급</strong> 할 수 있다.</p>
<h3 id="함수-디스크립터">함수 디스크립터</h3>
<p>람다 표현식의 시그니처를 서술하는 메서드를 <strong>함수 디스크립터</strong> 라고 한다. <code class="language-plaintext highlighter-rouge">() -&gt; void</code> 표기는 파라미터 리스트가 없으며 void를 반환하는 함수를 의미한다.</p>

<h2 id="람다-활용--실행-어라운드-패턴">람다 활용 : 실행 어라운드 패턴</h2>
<p>실제 자원을 처리하는 코드를 <code class="language-plaintext highlighter-rouge">설정</code>과 <code class="language-plaintext highlighter-rouge">정리</code> 두 과정이 둘러싸는 형태를 <strong>실행 어라운드 패턴</strong> 이라고 부른다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public String processFile() throws IOException {
    try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
        return br.readLine(); //실제 필요한 작업을 하는 행
    }
}
</code></pre></div></div>
<h3 id="1단계--동작-파라미터화를-기억하라">1단계 : 동작 파라미터화를 기억하라</h3>
<p>위의 코드에서 한 번에 한 줄만 읽을 수 있는 문제를 어떻게 개선할 수 있을끼? 람다를 이용해서 processFile의 동작을 파라미터화해보자.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>String result = processFile((BufferedReader br) -&gt; br.readLine() + br.readLine());
</code></pre></div></div>
<h3 id="2단계--함수형-인터페이스를-이용해서-동작-전달">2단계 : 함수형 인터페이스를 이용해서 동작 전달</h3>
<p>이번에는 <code class="language-plaintext highlighter-rouge">BufferedReader -&gt; String</code>과 <code class="language-plaintext highlighter-rouge">IOException</code>을 던질 수 있는 시그니처와 일치하는 함수형 인터페이스를 만들어서 동작을 전달해보자.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@FunctionalInterface
public interface BufferedReaderProcessor {
    String process(BufferedReader b) throws IOException;
}
public String processFile(BufferedReaderProcessor p) throws IOException {
    ...
}
</code></pre></div></div>
<h3 id="3단계--동작-실행">3단계 : 동작 실행</h3>
<p>람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public String processFile(BufferedReaderProcessor p) throws IOException {
    try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
        return p.process(br); //BufferedReader 객체 처리
    }
}
</code></pre></div></div>
<h3 id="4단계--람다-전달">4단계 : 람다 전달</h3>
<p>이제 람다를 이용해서 다양한 동작을 processFile 메서드로 전달할 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//한 행을 처리하는 코드
String oneLine = processFile((BufferedReader br) -&gt; br.readLine());
//두 행을 처리하는 코드
String twoLines = processFile((BufferedReader br) -&gt; br.readLine() + br.readLine());
</code></pre></div></div>
<h2 id="함수형-인터페이스-사용">함수형 인터페이스 사용</h2>
<p>다양한 함수형 인터페이스들을 알아보자.</p>
<h3 id="predicate">Predicate</h3>
<p><code class="language-plaintext highlighter-rouge">java.util.function.Predicate&lt;T&gt;</code> 인터페이스는 test라는 추상 메서드를 정의하며 test는 제네릭 형식 T의 객체를 인수로 받아 불리언을 반환한다.
따로 정의할 필요없이 불리언 표현식이 필요한 상황에서 바로 사용할 수 있다.</p>
<h3 id="consumer">Consumer</h3>
<p><code class="language-plaintext highlighter-rouge">java.util.function.Consumer&lt;T&gt;</code> 인터페이스는 제네릭 형식 T 객체를 받아서 void를 반환하는 accept라는 추상 메서드를 정의한다.
T 형식의 객체를 인수로 받아 어떤 동작을 수행하고 싶을 때 사용할 수 있다.</p>
<h3 id="function">Function</h3>
<p><code class="language-plaintext highlighter-rouge">java.util.function.Function&lt;T, R&gt;</code> 인터페이스는 제네릭 형식 T를 인수로 받아서 제네릭 형식 R 객체를 반환하는 추상 메서드 apply를 정의한다.
입력을 출력으로 매핑하는 람다를 정의할 때 활용할 수 있다.</p>
<h3 id="기본형-특화">기본형 특화</h3>
<p>위의 인터페이스들 외에도 특화된 형식의 함수형 인터페이스도 있다. 제네릭 파라미터에는 참조형(<code class="language-plaintext highlighter-rouge">Byte</code>, <code class="language-plaintext highlighter-rouge">Integer</code>, <code class="language-plaintext highlighter-rouge">Object</code>, <code class="language-plaintext highlighter-rouge">List</code>)만 사용할 수 있다.
<strong>박싱</strong> 은 기본형을 참조형으로 변환하는 기능이고, <strong>언박싱</strong> 은 참조형을 기본형으로 변환하는 기능이다. 또한, 이들이 자동으로 이루어지는 <strong>오토박싱</strong> 도 있다.<br />
자바 8에서는 이러한 오토방식 동작을 피할 수 있도록 IntPredicate과 같은 함수형 인터페이스를 제공한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public interface IntPredicate {
    boolean test(int t);
}
IntPredicate evenNumbers = (int i) -&gt; i % 2 == 0;
evenNumbers.test(1000); //참(박싱 없음)
Predicate&lt;Integer&gt; oddNumbers = (Integer i) -&gt; i % 2 != 0;
oddNumbers.test(1000); //거짓(박싱)
</code></pre></div></div>
<h2 id="형식-검사-형식-추론-제약">형식 검사, 형식 추론, 제약</h2>
<h3 id="형식-검사">형식 검사</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>List&lt;Apple&gt; heavierThan150g = filter(inventory, (Apple apple) -&gt; apple.getWeight() &gt; 150);
</code></pre></div></div>
<p>어떤 콘텍스트에서 기대되는 람다 표현식의 형식을 <strong>대상 형식</strong> 이라고 부른다. 위의 예제에서는 다음과 같은 순서로 형식 확인 과정이 진행된다.</p>
<ol>
  <li>filter 메서드의 선언 확인</li>
  <li>filter 메서드는 두 번째 파라미터로 <code class="language-plaintext highlighter-rouge">Predicate&lt;Apple&gt;</code> 형식을 기대</li>
  <li><code class="language-plaintext highlighter-rouge">Predicate&lt;Apple&gt;</code>은 test라는 한 개의 추상 메서드를 정의하는 함수형 인터페이스</li>
  <li>test 메서드는 Apple을 받아 boolean을 반환하는 함수 디스크립터</li>
  <li>filter 메서드로 전달된 인수는 이와 같은 요구사항을 만족해야 함</li>
</ol>

<h3 id="같은-람다-다른-함수형-인터페이스">같은 람다, 다른 함수형 인터페이스</h3>
<p>대상 형식이라는 특징 때문에 같은 람다 표현식이라도 다른 함수형 인터페이스로 사용될 수 있다.
즉, <strong>하나의 람다 표현식을 다양한 함수형 인터페이스에 사용</strong> 할 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Comparator&lt;Apple&gt; c1 =
    (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());
ToIntBiFunction&lt;Apple, Apple&gt; c2 =
    (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());
BiFunction&lt;Apple, Apple, Integer&gt; c3 =
    (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());
</code></pre></div></div>
<h3 id="형식-추론">형식 추론</h3>
<p>자바 컴파일러는 대상형식을 이용해서 람다 표현식과 관련된 함수형 인터페이스와 시그니처를 추론할 수 있다. 
때문에 람다 문법에서 이를 생략해서 코드를 더 단순하게 만들 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//형식을 추론하지 않음
Comparator&lt;Apple&gt; c = (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());
//형식을 추론함
Comparator&lt;Apple&gt; c = (a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight());
</code></pre></div></div>

<h3 id="지역-변수-사용">지역 변수 사용</h3>
<p>람다식에서 지역 변수는 <code class="language-plaintext highlighter-rouge">final</code>이 붙은 변경불가능한 지역변수만 사용해야 한다.</p>

<h2 id="메서드-참조">메서드 참조</h2>
<p><strong>메서드 참조</strong> 는 특정 람다 표현식을 축약한 것이라고 생각하면 된다. 메서드 참조를 이용하면 기존의 메서드 정의를 재활용해서 람다처럼 전달할 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//기존 코드
inventory.sort((Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));
//메서드 참조를 활용한 코드
inventory.sort(comparing(Apple::getWeight));
</code></pre></div></div>
<h3 id="특징">특징</h3>
<p>람다 표현식 대신 명시적으로 메서드명을 참조함으로써 코드의 <strong>가독성을 높일 수 있다</strong> 실제로 메서드를 호출하는 것은 아니므로 괄호는 필요 없다.
메소드 참조는 세 가지 유형으로 구분할 수 있다.</p>
<ol>
  <li><strong>정적 메서드 참조</strong> : 예를 들어 Integer의 parseInt 메서드는 Integer::parseInt로 표현할 수 있다.</li>
  <li><strong>다양한 형식의 인스턴스 메서드 참조</strong> : 예를 들어 String의 length 메서드는 String::length로 표현할 수 있다.</li>
  <li><strong>기존 객체의 인스턴스 메서드 참조</strong> : 예를 들어 Transaction 객체를 할당받은 expensiveTransaction 지역 변수가 있고,
Transaction 객체에는 getValue 메서드가 있다면, 이를 expensiveTransaction::getValue라고 표현할 수 있다.</li>
</ol>

<h3 id="생성자-참조">생성자 참조</h3>
<p><code class="language-plaintext highlighter-rouge">ClassName::new</code>처럼 클래스명과 new 키워드를 이용해서 기존 생성자의 참조를 만들 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Supplier&lt;Apple&gt; c1 = Apple::new;
Apple a1 = c1.get(); //Supplier의 get 메서드를 호출해서 새로운 Apple 객체를 만들 수 있다.
</code></pre></div></div>
<h2 id="람다-메서드-참조-활용하기">람다, 메서드 참조 활용하기</h2>
<p>지금까지 학습한 내용을 예제 코드에 적용해보자.</p>
<h3 id="1단계--코드-전달">1단계 : 코드 전달</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class AppleComparator implements Comparator&lt;Apple&gt; {
    public int compare(Apple a1, Apple a2) {
        return a1.getWeight().compareTo(a2.getWeight());
    }
}
inventory.sort(new AppleComparator());
</code></pre></div></div>
<h3 id="2단계--익명-클래스-사용">2단계 : 익명 클래스 사용</h3>
<p>한 번만 사용하는 <code class="language-plaintext highlighter-rouge">Comparator</code>는 위 코드보단 <strong>익명 클래스</strong> 를 이용하는 것이 좋다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inventory.sort(new Comparator&lt;Apple&gt;() {
    public int compare(Apple a1, Apple a2) {
        return a1.getWeight().compareTo(a2.getWeight());
    }
});
</code></pre></div></div>
<h3 id="3단계--람다-표현식-사용">3단계 : 람다 표현식 사용</h3>
<p>하지만, 여전히 코드가 가독성이 좋지 않다. <strong>람다 표현식</strong> 을 이용해 더 간결하게 코드를 개선해보자.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inventory.sort((Apple a1, Apple a2) -&gt;
                a1.getWeight().compareTo(a2.getWeight())
);
</code></pre></div></div>
<p>자바 컴파일러가 람다의 파라미터 형식을 추론할 수 있다고 학습했으므로 이 코드는 더 간결해질 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inventory.sort((a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));
</code></pre></div></div>
<p>이 코드는 <code class="language-plaintext highlighter-rouge">comparing</code> 메서드를 이용하면 더 가독성을 높일 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Comparator&lt;Apple&gt; c = Comparator.comparing((Apple a) -&gt; a.getWeight());
//더 간소화한 코드
inventory.sort(comparing(apple -&gt; apple.getWeight()));
</code></pre></div></div>
<h3 id="4단계--메서드-참조-사용">4단계 : 메서드 참조 사용</h3>
<p>마지막으로, <strong>메서드 참조</strong> 를 이용해 람다 표현식의 인수를 더 깔끔하게 전달해보자.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inventory.sort(comparing(Apple::getWeight));
</code></pre></div></div>
<p>이로써 코드가 간결해지고 의미도 명확해졌다!</p>
:ET