I"@-<h2 id="1장-컴퓨터-및-정보기술의-역사">1장 컴퓨터 및 정보기술의 역사</h2>
<h3 id="프로그래밍-언어의-역사">프로그래밍 언어의 역사</h3>
<ul>
  <li>기계어로 프로그래밍을 하는 불편함 &gt; 프로그래밍 언어의 필요성 &gt; 어셈블리 언어 등장 &gt;기계어의 동작 순서를 나타내는 언어보다 표현하고자 하는 문제 자체에 더 가까운 언어 <code class="language-plaintext highlighter-rouge">포트란</code> &gt; 기호 정보를 처리하는 일 필요 <code class="language-plaintext highlighter-rouge">리습Lisp</code> &gt; 사무적인 정보를 처리하기 위한 <code class="language-plaintext highlighter-rouge">코볼</code></li>
</ul>

<h3 id="운영체제의-역사">운영체제의 역사</h3>
<ul>
  <li>외부에서 미리 예약해 한꺼번에 처리하는 <code class="language-plaintext highlighter-rouge">일괄처리 방식(batch processing)</code> &gt; 자동적으로 처리해주도록 하는 방식 <code class="language-plaintext highlighter-rouge">운영체제</code> 탄생</li>
</ul>

<h3 id="현대의-컴퓨터">현대의 컴퓨터</h3>
<ul>
  <li>메인프레임 컴퓨터
    <ul>
      <li>은행, 항공사와 같은 대규모 사업장</li>
      <li>대량의 데이터 처리와 신뢰성 있는 전산작업을 위해 사용</li>
      <li>터미널을 통해 접속</li>
      <li>시분할 (time sharing) 방식 사용 : 컴퓨터 처리 능력을 짧은 시간 단위로 구분하고 이를 여러 사용자에게 조금씩 분할해 서비스하는 방식 (동시에 서비스하는 것처럼 보이지만, 아주 짧은 시간 간격으로 나누어 서비스하는 것)</li>
    </ul>
  </li>
  <li>슈퍼컴퓨터 또는 고성능 컴퓨터
    <ul>
      <li>클라우드 컴퓨팅 : 원격으로 고성능 컴퓨터를 사용하고 사용료를 지불하는 형태의 컴퓨팅 방식</li>
      <li>아마존, 구글, 마이크로소프트 등</li>
      <li>고성능컴퓨터의 능력을 조금씩 분할하여 한 대의 물리적인 컴퓨터를 여러 사용자들이 공유해서 사용</li>
    </ul>
  </li>
  <li>개인용 컴퓨터</li>
  <li>휴대용 컴퓨터</li>
  <li>임베디드 컴퓨터 또는 내장형 컴퓨터
    <ul>
      <li>특수 임무를 수행하도록 개발된 컴퓨터, 기기 내부에 장착되는 형태</li>
      <li>각종 기기에 내장되어 기능을 향상시키거나 연산, 처리, 전달하는 업무 담당</li>
      <li>프로그램이 칩 내부에 구워져 있음 ⇒ 새로운 프로그램 탑재 불가</li>
    </ul>
  </li>
</ul>

<h2 id="2장-운영체제-개요">2장 운영체제 개요</h2>
<h3 id="운영체제의-정의">운영체제의 정의</h3>
<ul>
  <li>컴퓨터 하드웨어 바로 윗단에 설치되는 소프트웨어</li>
  <li>사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층</li>
  <li>하드웨어 + 운영체제 = 진정한 컴퓨터 시스템</li>
  <li>컴퓨터 전원을 켜면 동시에 실행</li>
  <li>자체도 하나의 소프트웨어이기 때문에 전원이 켜짐과 동시에 메모리에 올라감
    <ul>
      <li>필요한 부분(커널)만 전원이 켜질 때 메모리에 올려놓고 그렇지 않은 부분은 필요할 때 메모리로 올려 사용</li>
    </ul>
  </li>
</ul>

<h3 id="운영체제의-기능">운영체제의 기능</h3>
<ul>
  <li>하드웨어를 위한 역할 : 사용자가 직접 다루기 힘든 각종 하드웨어를 운영체제가 관리
    <ul>
      <li>컴퓨터 시스템 내의 <strong>자원을 효율적으로 관리</strong> ⇒ <code class="language-plaintext highlighter-rouge">자원관리자(resource manager)</code></li>
    </ul>
  </li>
  <li>사용자를 위한 역할 : 편리한 인터페이스를 제공
    <ul>
      <li>컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공</li>
    </ul>
  </li>
  <li>보안 및 보호 기능</li>
</ul>

<h3 id="운영체제의-분류">운영체제의 분류</h3>
<ol>
  <li>동시 작업 지원 여부
    <ul>
      <li>단일작업 (single tasking) : 한 번에 하나의 프로그램만 실행</li>
      <li>다중작업 (multi tasking) : 동시에 2개 이상의 프로그램을 처리</li>
    </ul>
    <ul>
      <li>시분할 시스템 (time sharing system) : CPU의 작업시간을 여러 프로그램들이 조금씩 나누어 쓰는 시스템</li>
      <li>다중 프로그래밍 시스템 (multi-programming system) : 메모리 공간을 분할해 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 시스템</li>
      <li>대화형 시스템 (interactive system) : 사용자의 입력에 대한 결과를 곧바로 보여주는 시스템<br />
주의 : 다중처리기 시스템 (multi-processor system) : 하나의 컴퓨터 안에 CPU가 여러 개 설치된 경우</li>
    </ul>
  </li>
  <li>다중 사용자에 대한 동시 지원 여부
    <ul>
      <li>단일 사용자용 운영체제 : 한 번에 한 명의 사용자만 사용하도록 허용 (DOS, MS 윈도우)</li>
      <li>다중 사용자용 운영체제 : 여러 사용자가 동시에 접속해 사용하도록 허용 (이메일 서버, 웹서버)</li>
    </ul>
  </li>
  <li>작업을 처리하는 방식
    <ul>
      <li>일괄처리 (batch processing) : 요청된 작업을 일정량씩 모아서 한꺼번에 처리</li>
    </ul>
    <ul>
      <li>모든 작업이 완전히 종료된 후에 결과 확인가능 ⇒ 응답시간이 길다는 단점
    - 시분할 (time sharing) : 컴퓨터의 처리 능력을 일정한 시간 단위로 분할해 사용</li>
      <li>여러 사용자의 작업을 짧은 시간 단위씩 번갈아가며 처리 ⇒ 짧은 응답시간
    - 실시간 (real time) : 정해진 시간 안에 어떠한 일이 반드시 처리됨을 보장해야 하는 시스템에서 사용</li>
      <li>일정시간 안에 작업이 완료되지 못할 경우, 위험을 초래할 가능성이 있는 시스템
        <ol>
          <li>경성 실시간 시스템 (hard realtime system) : 주어진 시간을 지키지 못할 경우 매우 위험</li>
          <li>연성 실시간 시스템 (soft realtime system) : 멀티미디어 스트리밍 시스템</li>
        </ol>
      </li>
    </ul>
  </li>
</ol>

<h3 id="운영체제의-예">운영체제의 예</h3>
<ul>
  <li>MS 윈도우 : MS-DOS의 업그레이드 버전
    <ul>
      <li>마이크로소프트에서 개발한 개인용 컴퓨터를 위한 운영체제</li>
      <li>✅ 그래픽 인터페이스와 마우스 지원으로 사용자에게 편리한 환경</li>
      <li>❌ MS-DOS 위에서 수행되기 때문에 독립적이지 않음, 불안정<br />
⇒ 하나의 온전한 운영체제 윈도우 95 ⇒ 윈도우 98 ⇒ XP ⇒ Vista ⇒ 7 ⇒ 윈도우 10</li>
    </ul>
  </li>
  <li>유닉스
    <ul>
      <li>프로그램 개발 환경을 위해 설계된 운영체제</li>
      <li>✅ 이식성(portability)이 좋고, 운영체제 커널의 크기가 작으며, 소스 코드가 공개되었다는 점</li>
    </ul>
  </li>
</ul>

<h3 id="운영체제의-자원-관리-기능">운영체제의 자원 관리 기능</h3>
<ul>
  <li>하드웨어 자원 : CPU와 메모리를 비롯해 주변장치 또는 입출력 장치라 불리는 장치들</li>
  <li>CPU 스케줄링 : CPU를 가장 효율적으로 사용하면서도 특정 프로세스가 불이익을 당하지 않도록 하는 것
    <ol>
      <li>선입선출 (First Come First Served) : 먼저 온 것 먼저 처리
        <ul>
          <li>CPU 자체의 효율저 사용은 문제 없지만 전체 시스템 입장에서는 비효율적</li>
          <li>❌ 짧은 시간만 CPU를 사용하면 되는 프로세스들이 계속 기다려야 됨</li>
        </ul>
      </li>
      <li>라운드 로빈 (Round Robin)
        <ul>
          <li>CPU를 한 번 할당받아 사용할 수 있는 시간을 고정된 시간으로 제한</li>
          <li>일정 시간이 지나면 CPU를 내어놓고 제일 뒤로 가서 줄 서야 함</li>
          <li>일반적으로 할당시간은 밀리초 단위를 사용해서 1초 이하의 응답시간을 보장</li>
        </ul>
      </li>
      <li>우선순위 (priority)
        <ul>
          <li>우선순위가 높은 프로세스에 CPU 먼저 할당</li>
          <li>기다린 시간이 늘어날수록 우선순위를 높임</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>메모리 관리 : 한정된 메모리 공간에 여러 프로그램을 수용하기 위해
    <ol>
      <li>고정분할 (fixed partition)
        <ul>
          <li>물리적 메모리를 몇 개의 분할로 미리 나누어 관리</li>
          <li>❌ 융통성이 없음 (메모리에 동시 적재되는 최대 프로그램 수가 분할 개수로 한정됨)</li>
          <li>❌ 메모리를 효율적으로 사용할 수 없음 (분할의 크기보다 큰 프로그램은 적재 불가능, 분할의 크기보다 작은 프로그램이 적재되는 경우 메모리 낭비)</li>
          <li>내부조각 : 해당 분할에 올라온 프로그램에 의해 사용되지 않고, 다른 프로그램에도 할당될 수 없는 낭비공간</li>
        </ul>
      </li>
      <li>가변분할 (variable partition)
        <ul>
          <li>매 시점 프로그램의 크기에 맞게 메모리 분할해서 사용</li>
          <li>❌ 물리적 메모리의 크기보다 더 큰 프로그램은 여전히 불가능</li>
          <li>분할의 크기와 개수가 동적으로 변하므로 기술적 관리기법 필요</li>
          <li>외부조각 : 프로그램에 할당되지는 않았지만 크기가 작아 프로그램을 올리지 못하는 낭비공간</li>
        </ul>
      </li>
      <li><strong>가상메모리 (virtual memory)</strong> : 가장 널리 사용되는 메모리 관리 기법
        <ul>
          <li>✅ 물리적 메모리보다 더 큰 프로그램이 실행되는 것 지원</li>
          <li>모든 프로그램은 물리적 메모리와 독립적으로 0번지부터 시작하는 자신만의 가상메모리 주소를 가짐</li>
          <li>운영체제는 이 가상메모리 주소를 물리적 메모리 주소로 매핑하는 기술을 이용해 주소 변환 후 프로그램을 물리적 메모리에 올림</li>
          <li>현재 사용되고 있는 부분만 메모리에 올리고, 나머지는 하드디스크와 같은 보조기억장치(스왑 영역)에 저장해두었다가 필요할 때 적재</li>
          <li>페이징(paging) : 동일한 단위로 메모리를 나누는 기법, 프로그램을 구성하는 가상메모리 주소 공간은 페이지(page)라는 동일한 크기의 작은 단위로 나누어 물리적 메모리와 스왑 영역에 일부분씩 저장
        - 인터럽트 : 주변장치 및 입출력 장치의 관리</li>
          <li>주변장치들은 CPU가 필요한 경우 신호를 발생시켜 서비스를 요청 ⇒ 인터럽트</li>
          <li>CPU는 스케줄링에 따라 작업을 수행하다가 인터럽트가 발생하면 잠시 멈추고 요청 서비스 수행 ⇒ 인터럽트 처리 완료 후 원래 하던 작업 계속 수행</li>
          <li>일터럽트가 발생했을 때 직전의 작업상태를 잠시 저장해둠</li>
          <li>컨트롤러(controller) : 각 장치마다 일어나는 업무를 관리하기 위한 작은 CPU</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>
:ET