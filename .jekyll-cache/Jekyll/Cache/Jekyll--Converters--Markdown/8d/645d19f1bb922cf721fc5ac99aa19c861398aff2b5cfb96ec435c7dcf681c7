I".<h1 id="1-http-리퀘스트-메시지를-작성한다">1. HTTP 리퀘스트 메시지를 작성한다</h1>
<h3 id="1-url-입력">1. URL 입력</h3>
<ul>
  <li>모든 URL의 맨 앞에 (<code class="language-plaintext highlighter-rouge">http:</code>, <code class="language-plaintext highlighter-rouge">ftp:</code>, <code class="language-plaintext highlighter-rouge">file:</code>, <code class="language-plaintext highlighter-rouge">mailto:</code>)와 같은 액세스 방법을 나타내는 문자열이 붙음</li>
  <li>http : 액세스 대상이 웹 서버, HTTP 프로토콜 사용</li>
  <li>ftp : 엑세스 대상이 FTP 서버, FTP 프로토콜 사용</li>
</ul>

<h3 id="2-url-해독">2. URL 해독</h3>

<div style="width:50% !important; margin:0 auto">
<img src="/assets/img/network1-1.png" alt="network1-1.png" />
</div>

<ul>
  <li>
    <p>URL의 요소 (ex. http://www.lab.cyber.co.kr/dir1/file1.html)</p>

    <p><code class="language-plaintext highlighter-rouge">http:</code> + <code class="language-plaintext highlighter-rouge">//</code> + <code class="language-plaintext highlighter-rouge">웹 서버명</code> + <code class="language-plaintext highlighter-rouge">/</code> + <code class="language-plaintext highlighter-rouge">디렉토리명</code> + <code class="language-plaintext highlighter-rouge">/</code> + … + <code class="language-plaintext highlighter-rouge">파일명</code></p>
  </li>
</ul>

<h3 id="3-파일명-생략한-경우">3. 파일명 생략한 경우</h3>
<ul>
  <li>http://www.lab.cyber.co.kr/dir<strong>/</strong> : 끝에 디렉토리명 다음 파일명을 생략하고 <code class="language-plaintext highlighter-rouge">/</code> 로 끝난 경우, 미;리 서버측에 설정해둔 기본 파일명으로 엑세스 (index.html, default.htm)</li>
  <li>http://www.lab.cyber.co.kr<strong>/</strong> : 끝에 <code class="language-plaintext highlighter-rouge">/</code> 가 있으므로 <code class="language-plaintext highlighter-rouge">/</code> 라는 디렉토리의 기본 파일에 엑세스</li>
  <li>http://www.lab.cyber.co.kr : 끝에 <code class="language-plaintext highlighter-rouge">/</code> 까지 모두 생략된 경우, 루트 디렉토리 아래의 기본 파일에 엑세스</li>
  <li>http://www.lab.cyber.co.kr<strong>/whatisthis</strong> : 끝에 <code class="language-plaintext highlighter-rouge">/</code> 가 없으므로 파일명으로 보는 것이 맞지만 이런 경우 웹서버에 해당 파일이 있으면 파일명으로, 해당 디렉토리가 있으면 디렉토리로 간주</li>
</ul>

<h3 id="4-http의-기본-개념">4. HTTP의 기본 개념</h3>
<ul>
  <li>HTTP 프로토콜 : 클라이언트와 서버가 주고받는 메시지의 내용이나 순서를 정한 것</li>
  <li>URI : 리퀘스트 메시지 안의 <code class="language-plaintext highlighter-rouge">무엇을</code> 에 해당, <code class="language-plaintext highlighter-rouge">/index.html</code></li>
  <li>메서드 : 리퀘스트 메시지 안의 <code class="language-plaintext highlighter-rouge">어떻게</code> 에 해당, <code class="language-plaintext highlighter-rouge">GET</code>, <code class="language-plaintext highlighter-rouge">POST</code>
    <ul>
      <li><strong>GET</strong> : 웹 서버에 엑세스하여 페이지의 <strong>데이터를 읽을 때</strong> 사용</li>
      <li><strong>POST</strong> : <strong>폼에 데이터를 사용</strong>해서 웹 서버에 송신하는 경우 사용</li>
    </ul>

    <div style="width:50% !important; margin:0 auto">
  <img src="/assets/img/network1-2.png" alt="network1-2.png" />
  </div>
  </li>
  <li>Status code : 실행 결과를 나타내는 코드, <code class="language-plaintext highlighter-rouge">404 Not Found</code></li>
</ul>

<h3 id="5-http-request">5. HTTP Request</h3>
<ul>
  <li>Request Line : 리퀘스트 메시지의 첫 번째 행 <code class="language-plaintext highlighter-rouge">GET /index.html HTTP/1.1</code> (메서드, URI, HTTP버전)</li>
  <li>Message Header : 리퀘스트 메시지의 두 번째 행부터 이어지는 내용(날짜, 데이터의 종류, 언어, 압축 형식, 버전, 데이터 유효기간 등 다수의 항목 포함)</li>
  <li>메시지 본문 : 메시지 헤더 뒤 공백 행 다음 이어지는 내용, <strong>POST일 때만 포함</strong> (송신할 데이터)</li>
</ul>

<h3 id="6-http-response">6. HTTP Response</h3>

<div style="width:50% !important; margin:0 auto">
<img src="/assets/img/network1-3.png" alt="network1-3.png" />
</div>

<ul>
  <li>Status Line : 실행 결과를 나타내는 Status code와 Status Message 포함</li>
  <li>Message Header</li>
</ul>

<blockquote>
  <p>리퀘스트 메시지에 쓰는 URI는 하나뿐으로, 복수의 파일을 읽어올 때는 웹 서버에 별도의 리퀘스트 메시지를 보낸다.</p>
</blockquote>

<h1 id="2-웹-서버의-ip-주소를-dns-서버에-조회한다">2. 웹 서버의 IP 주소를 DNS 서버에 조회한다</h1>
<h3 id="1-ip주소의-기본">1. IP주소의 기본</h3>
<ul>
  <li>IP주소 = 네트워크 번호 + 호스트 번호</li>
  <li><a href="https://xrabcde.github.io/csstudy-network1/">Network/네트워크계층/IP주소와 서브넷</a></li>
</ul>

<h3 id="2-도메인명과-ip주소를-구분하여-사용하는-이유">2. 도메인명과 IP주소를 구분하여 사용하는 이유</h3>
<ul>
  <li>숫자로 된 IP주소를 기억하기 어려우므로 서버의 이름을 도메인으로 사용</li>
  <li>도메인명을 IP주소 대신 사용하면 실행 효율이 떨어짐<br />
⇒ 사람은 이름을 사용하고, 라우터는 IP주소를 사용하는 방법으로 결정!</li>
</ul>

<h3 id="3-socket-라이브러리가-ip주소를-찾는-기능을-제공한다">3. Socket 라이브러리가 IP주소를 찾는 기능을 제공한다</h3>
<ul>
  <li>DNS 서버에 도메인에 해당하는 IP 주소를 알려달라고 요청해서 IP 주소를 찾음</li>
  <li>네임 리졸루션 : DNS의 원리를 사용하여 IP 주소를 조사하는 것</li>
  <li>리졸버 : 리졸루션을 실행하는 것, DNS 클라이언트에 해당</li>
</ul>

<h1 id="3-전-세계의-dns-서버가-연대한다">3. 전 세계의 DNS 서버가 연대한다</h1>
<h3 id="1-dns-서버의-기본-동작">1. DNS 서버의 기본 동작</h3>
<ul>
  <li>클라이언트에서 조회 메시지를 받고 조회의 내용에 응답하는 형태로 정보를 회답하는 일</li>
  <li>조회 메시지 : 이름 + 클래스 + 타입</li>
  <li>DNS 서버는 등록된 정보를 찾아서 이름, 클래스, 타입의 세 가지가 일치하는 것을 찾아 해당하는 IP 주소를 클라이언트에게 회답</li>
</ul>

<blockquote>
  <p>DNS 서버는 서버에 등록된 도메인명과 IP주소의 대응표를 조사하여 IP주소를 회답</p>
</blockquote>

<h3 id="2-도메인의-계층">2. 도메인의 계층</h3>
<ul>
  <li>정보를 전부 한 대의 DNS 서버에 등록할 수 없으므로 정보를 분산시켜 다수의 DNS 서버에 등록하고 다수의 DNS 서버가 연대하여 어디에 정보가 등록되어 있는지를 찾아내는 구조</li>
  <li>도메인과 도메인명 : <code class="language-plaintext highlighter-rouge">www.cyber.com</code> com 이라는 도메인 아래에 cyber라는 도메인이 있고 그 안에 www라는 이름이 있음</li>
</ul>

<h3 id="3-담당-dns-서버를-찾아-ip-주소를-가져온다">3. 담당 DNS 서버를 찾아 IP 주소를 가져온다</h3>
<ul>
  <li>액세스 대상의 웹 서버가 어느 DNS 서버에 등록되어 있는지 찾아내는 방법</li>
  <li>
    <p>하위의 도메인을 담당하는 DNS 서버의 IP 주소를 상위의 DNS 서버에 등록 &gt; 상위의 DNS 서버를 또 그 상위의 DNS 서버에 등록하는 식으로 차례대로 등록<br />
⇒ 상위의 DNS 서버에 가면 하위의 DNS 서버의 IP 주소를 알 수 있고, 조회 메시지를 보낼 수 있음</p>
  </li>
  <li>최상위 도메인(com, kr)은 루트 도메인 DNS 서버에 등록하고 루트 도메인의 DNS 서버를 인터넷에 존재하는 DNS 서버에 전부 등록</li>
  <li>클라이언트에서 어딘가의 DNS 서버에 엑세스하면 여기에서부터 루트 도메인을 경유하여 도메인의 계층 아래로 찾아가 최종적으로 원하는 DNS 서버에 도착</li>
</ul>

<h3 id="4-dns-서버는-캐시-기능으로-빠르게-회답할-수-있다">4. DNS 서버는 캐시 기능으로 빠르게 회답할 수 있다</h3>
<ul>
  <li>DNS 서버는 한 번 조사한 이름을 캐시에 기록 ⇒ 루트 도메인부터 찾기 시작하는 것보다 더 편리</li>
  <li>조회한 이름이 등록되어 있지 않은 경우도 캐싱해서 빠르게 회답가능</li>
  <li>주의 : 캐시 안 정보는 반드시 올바르다고 단언할 수 없으므로 데이터의 유효 기간이 지나면 캐시에서 삭제하고 회답 시 캐싱된 정보인지 조회된 정보인지 명시</li>
</ul>

<h1 id="4-프로토콜-스택에-메시지-송신을-의뢰한다">4. 프로토콜 스택에 메시지 송신을 의뢰한다</h1>
<h3 id="1-데이터-송수신-동작의-개요">1. 데이터 송수신 동작의 개요</h3>
<ul>
  <li>데이터 송수신은 파이프와 같음 : 한쪽 끝에서 파이프에 데이터를 쏟아부으면 파이프를 통해 반대쪽에 도착하고 양방향으로 데이터를 보낼 수 있음</li>
  <li>송수신 동작을 하기 전 둘 사이를 파이프로 연결하는 동작이 필요함</li>
  <li><code class="language-plaintext highlighter-rouge">소켓</code> : 데이터의 출입구, 파이프의 양 끝
    <ul>
      <li>먼저 서버측에서 소켓을 만들고 소켓에 클라이언트가 파이프를 연결하기를 기다림</li>
      <li>클라이언트측에도 소켓을 만들고 소켓에서 파이프를 늘려 서버측의 소켓에 연결</li>
    </ul>
  </li>
  <li>데이터를 전부 보내고 나면 파이프가 분리됨</li>
  <li>파이프의 연결 : 클라이언트측 &gt; 서버측</li>
  <li>파이프의 분리 : 어느 쪽에서 분리해도 상관없음</li>
  <li>과정</li>
</ul>

<ol>
  <li>소켓을 만든다 (소켓 작성 단계)</li>
  <li>서버측의 소켓에 파이프를 연결한다 (접속 단계)</li>
  <li>데이터를 송수신한다 (송수신 단계)</li>
  <li>파이프를 분리하고 소켓을 말소한다 (연결 끊기 단계)</li>
</ol>

<ul>
  <li>위의 동작을 실행하는 것은 OS 내부의 <strong>프로토콜 스택</strong></li>
</ul>

<h3 id="2-소켓의-작성-단계">2. 소켓의 작성 단계</h3>
<ul>
  <li>Socket 라이브러리의 socket 메서드를 호출하여 소켓을 만듦</li>
  <li>소켓이 생기면 디스크립터라는 것이 반환되고 애플리케이션은 이것을 메모리에 기록</li>
  <li>디스크립터 : 소켓을 식별하기 위해 사용 (여러 개의 창이 열려있을 때 구분하기 위한 용도)</li>
</ul>

<h3 id="3-파이프를-연결하는-접속-단계">3. 파이프를 연결하는 접속 단계</h3>
<ul>
  <li>Socket 라이브러리의 connect 메서드를 호출하여 서버측 소켓에 연결
    <ul>
      <li>디스크립터 : 애플리케이션이 소켓을 식별하는 것</li>
      <li>서버의 IP주소, 포트 번호 : 클라이언트와 서버 간에 상대의 소켓을 식별하는 것</li>
    </ul>
  </li>
</ul>

<h3 id="4-메시지를-주고받는-송수신-단계">4. 메시지를 주고받는 송수신 단계</h3>
<ul>
  <li>Socket 라이브러리의 write 메서드를 호출하여 데이터 송신</li>
  <li>Socket 라이브러리의 read 메서드를 호출하여 데이터 수신</li>
</ul>

<h3 id="5-연결-끊기-단계에서-송수신이-종료된다">5. 연결 끊기 단계에서 송수신이 종료된다</h3>
<ul>
  <li>Socket 라이브러리의 close 메서드를 사용하여 연결 끊기</li>
</ul>
:ET