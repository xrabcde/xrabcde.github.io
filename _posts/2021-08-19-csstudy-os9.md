---
layout: post
title: Operating System/9장 - 디스크 관리
date: 2021-08-19
excerpt: "운영체제 스터디 #9 디스크 관리"
tags: [csstudy, operating_system]
comments: true
---

- 디스크 : 컴퓨터 시스템의 대표적인 2차 저장장치, 메모리와 달리 **비휘발성**
## 디스크의 구조
- 디스크는 `논리블록`(일정한 크기의 저장공간)들로 이루어진 1차원 배열
- 데이터가 저장될 때에도 `논리블록` 단위로 저장되고, 입출력이 일어날 때도 `논리블록` 단위로 전송됨
- 각 논리블록이 저장되는 디스크내의 물리적 위치를 `섹터`라고 부름 (논리블록 하나가 섹터 하나와 1대1 매핑)
- 디스크의 물리적 구조 > 마그네틱 원판 (한 개 혹은 여러 개) > 트랙 > 섹터(최소한의 단위 정보 저장)
- `실린더` : 여러 개의 원판에서 상대적 위치가 동일한 트랙들의 집합
- `암` : 데이터를 읽고 쓰기 위해 해당 섹터가 위치한 실린더로 이동해서 원판이 회전하며 해당 섹터위치에 도달

<div style="width:60% !important; margin:0 auto">
<img src="/assets/img/os9-1.png" alt="os9-1.png">
</div>

## 디스크 스케줄링
- 디스크에 대한 접근시간 = 탐색시간 + 회전지연시간 + 전송시간
1. **탐색시간** : 디스크 헤드를 해당 실린더 위치로 이동시키는 데 걸리는 시간
2. 회전지연시간 : 디스크가 회전해서 읽고 쓰려는 섹터가 헤드 위치에 도달하기까지 걸리는 시간
3. 전송시간 : 해당 섹터가 헤드 위치에 도달한 후 데이터를 실제로 섹터에 읽고 쓰는 데 소요되는 시간
- 디스크 입출력 효율을 높이기 위해서는 디스크 접근시간을 최소화해야 함 (BUT 회전지연시간과 전송시간은 수치도 작고 통제하기 힘듦 ⇒ **탐색시간을 최소화!**)
- **디스크 스케줄링** : 여러 섹터들에 대한 입출력 요청이 들어왔을 때 어떤 순서로 처리할 것인지 결정하는 매커니즘 ⇒ **디스크 헤드의 이동거리를 줄이는 것이 목표!**

### 1. FCFS 스케줄링 (First Come First Served)
- 먼저 들어온 요청 먼저 처리

> 실린더 위치 : 0-199, 현재 헤드 : 54, 요청 : **99 184 36 123 15 125 66 68**

- 디스크 헤드가 54번 실린더에서 출발해 99 > 184 > 36 > ... 순으로 이동
- 총 헤드의 이동거리 : 644

<div style="width:60% !important; margin:0 auto">
<img src="/assets/img/os9-2.png" alt="os9-2.png">
</div>

- ex. 은행창구, 매표소
- ❌ 디스크 헤드가 움직이면서 서비스를 해야하므로 효율성이 매우 떨어짐

### 2. SSTF 스케줄링 (Shortest Seek Time First)
- 현재 위치로부터 가장 가까운 위치에 있는 요청을 먼저 처리

> 실린더 위치 : 0-199, 현재 헤드 : 54, 요청 : **99 184 36 123 15 125 66 68**

- 현재 위치 54에서 가장 가까운 66번 요청 먼저 처리 > 68 > 36 > ...
- 총 헤드의 이동거리 : 236

<div style="width:60% !important; margin:0 auto">
<img src="/assets/img/os9-3.png" alt="os9-3.png">
</div>

- ✅ 헤드의 이동거리를 줄여 디스크 입출력 효율성 증가
- ❌ `기아 현상(starvation)` : 현재 위치로부터 가까운 요청이 지속적으로 들어올 경우 멀리 떨어진 곳의 요청은 무한히 기다려야 함

⇒ FCFS와 비교해서 헤드의 이동거리를 많이 줄일 수 있지만 가장 우수한 알고리즘은 아님

### 3. SCAN 알고리즘
- 헤드가 디스크의 안쪽 끝과 바깥쪽 끝을 오가며 경로에 존재하는 모든 요청 처리
- ex. 버스가 일정 경로에 따라 움직이며 정류장에서 사람들을 태우는 방식

> 실린더 위치 : 0-199, 현재 헤드 : 54, 요청 : **99 184 36 123 15 125 66 68**

- 헤드가 현재 위치 54에서 0번 방향으로 이동중이라면 36 > 15 > 0에서 방향 바꾸고 > 66 > ...
- 총 헤드의 이동거리 : 238

<div style="width:60% !important; margin:0 auto">
<img src="/assets/img/os9-4.png" alt="os9-4.png">
</div>

- ex. 엘리베이터 스케줄링 알고리즘
- ✅ FCFS처럼 불필요한 헤드 이동 없음
- ✅ SSTF처럼 일부 지역이 지나치게 오래 기다리는 기아 현상 없음

⇒ 효율성과 형평성 모두 만족하는 알고리즘

- ❌ 모든 실린더 위치의 기다리는 시간이 공평하지는 않음 (끝쪽보다 가운데 위치가 기다리는 평균시간이 더 짧음)

### 4. C-SCAN 알고리즘
- SCAN 알고리즘의 위치에 따른 탐색시간 편차를 보완하기 위해 나온 알고리즘
- SCAN 처럼 한쪽 끝에서 다른쪽 끝으로 이동하는 것은 같지만 **방향을 바꾸지 않고 한방향으로만 움직임**

> 실린더 위치 : 0-199, 현재 헤드 : 54, 요청 : **99 184 36 123 15 125 66 68**

- 현재 위치 54에서 199까지 가면서 66 > 68 > 99 > 123 > ...
- 총 헤드의 이동거리 : 380

<div style="width:60% !important; margin:0 auto">
<img src="/assets/img/os9-5.png" alt="os9-5.png">
</div>

- ✅ SCAN보다 헤드의 이동거리는 길어지지만 탐색시간의 편차를 줄일 수 있음

### 5. LOOK과 C-LOOK 알고리즘
- 요청 존재여부와 관계없이 무조건 한쪽 끝에서 다른쪽 끝까지 이동하는 SCAN 알고리즘과 달리 **그 방향에 더이상 요청이 없으면 방향을 즉시 반대로 바꾸는 방식**
- C-LOOK은 C-SCAN과 마찬가지로 한쪽 방향으로만 이동함

> 실린더 위치 : 0-199, 현재 헤드 : 54, 요청 : **99 184 36 123 15 125 66 68**

- 현재 위치 54에서 66 > 68 > ... 까지는 SCAN과 동일하지만 184에서 더이상 요청이 없으므로 바로 방향을 바꿈

<div style="width:60% !important; margin:0 auto">
<img src="/assets/img/os9-6.png" alt="os9-6.png">
</div>

- ✅ 헤드가 반드시 끝까지 이동하는 것이 아니라 요청이 존재하는 가장 낮은 번호까지만 이동하므로 디스크 이동거리 줄일 수 있음

## 다중 디스크 환경에서의 스케줄링
- 수많은 동시 사용자를 서비스하는 서버에서는 동일한 정보를 여러 디스크에 중복 저장함
    - ✅ 인기 있는 데이터를 여러 디스크로부터 동시에 서비스 가능
    - ✅ 일부 디스크 오류가 발생해도 지속적 서비스 가능
    - ✅ 정보의 유실 방지

  ⇒ 시스템의 성능과 신뢰성 동시에 향상

- 하나의 디스크가 아닌 다중 디스크 환경에서 어느 디스크 요청을 처리할지 결정하는 문제
    1. 각 디스크 간의 **부하균형(load balancing)을 이루도록 스케줄링**
    2. 전력 소모를 줄이기 위해 일부 디스크에 요청을 집중시키고 나머지는 휴면하도록 스케줄링 (부하편향 기법)

## 디스크의 저전력 관리
### 1. 비활성화 기법
- 디스크의 상태는 전력소모를 기준으로 크게 네 가지 상태로 구분

1. 활동 (active) 상태 : 현재 헤드가 데이터를 읽거나 쓰고 있는 상태
2. 공회전 (idle) 상태 : 디스크가 회전중이지만 데이터를 읽거나 쓰지는 않는 상태
3. 준비 (standby) 상태 : 디스크가 회전하지 않지만 인터페이스가 활성화된 상태
4. 휴면 (sleep) 상태 : 디스크가 회전하지 않고 인터페이스도 비활성화된 상태

⇒ 1,2는 활성 상태 / 3,4는 비활성 상태

- 요청이 없는 경우 디스크를 정지시키는 것이 전력 절감 측면에서 효과적

### 2. 회전속도 조절 기법
- 디스크의 회전속도를 가변적으로 조절하는 기법

### 3. 디스크의 데이터 배치 기법
- 디스크 내에 데이터의 복제본을 많이 만들어 헤드 위치에서 가까운 복제본에 접근하도록 하는 기법

### 4. 버퍼캐싱 및 사전인출 기법
- 디스크가 저전력 모드일 때는 입출력 처리를 최대한 지연시켰다가 정상 전력 모드로 돌아왔을 때 사전인출을 공격적으로 하는 기법

### 5. 쓰기전략을 통한 저전력 디스크 기법
- 디스크가 비활성 상태일 때는 쓰기를 하지 않고 기다렸다가, 활성상태로 돌아왔을 때 쓰는 방식
