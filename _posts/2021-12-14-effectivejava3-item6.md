---
layout: post
title: Book/Effective Java 3E/Item6. 불필요한 객체 생성을 피하라
date: 2021-12-14
excerpt: "이펙티브 자바 3판 - 아이템 6. 불필요한 객체 생성을 피하라"
tags: [book, effective_java, java]
comments: true
---

똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 것이 좋다.
특히, 불변 객체는 언제든 재사용할 수 있다.
```
String s = new String("test");
```
위의 코드는 **실행될 때마다 String 인스턴스를 새로 만드는 비효율적인 코드**이다.
이 코드가 반복문이나 빈번히 호출되는 메서드 안에 있다면 필요없는 String 인스턴스가 수백만 개 만들어질 수도 있다.
```
String s = "test";
```
반면 이 코드는 **새로운 인스턴스를 매번 만드는 대신 하나의 String 인스턴스를 사용**한다.
이 방식을 사용한다면 똑같은 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 재사용함이 보장된다.  
생성자 대신 정적 팩터리 메서드를 제공하는 불변 클래스에서는 정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다.
생성자는 호출할 때마다 새로운 객체를 만들지만, 팩터리 메서드는 그렇지 않다.

```
// 권장하지 않는 코드
static boolean isRomanNumeral(String s) {
    return s.matches("^(?~~})");
}

// 개선한 코드
public class RomanNumerals {
    private static final Pattern ROMAN = Pattern.compile("^(?~~})");
    
    static boolean isRomanNumeral(String s) {
        return ROMAN.matcher(s).matches();
    }
}
```
생성 비용이 **아주 비싼 객체의 경우 반복해서 필요하다면 캐싱하여 재사용하는 것이 좋다.**
위의 코드에서 사용한 `String.matches`는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만,
성능이 중요한 상황에서 반복해 사용하기엔 적합하지 않다.  
첫 번째 코드에서는 메서드 내부에서 정규표현식용 Pattern 인스턴스가 호출될 때마다 한 번 쓰고 버려지게 된다. 
반면 두 번째 코드와 같이 불변 Pattern 인스턴스를 클래스 초기화 과정에서 직접 생성해 캐싱해둔다면,
이 메서드가 호출될 때마다 이 인스턴스를 재사용하게 된다.
이렇게 개선하면 메서드가 빈번히 호출되는 상황에서 성능을 상당히 개선할 수 있을 뿐 아니라, 코드도 더 명확해진다.

```
private static long sum() {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;
    }
    return sum;
}
```
불필요한 객체를 만들어내는 또 다른 예로 오토박싱을 들 수 있다.
오토박싱은 개발자가 기본 타입과 박싱된 기본 타입을 섞어 사용할 때 자동으로 형변환을 해주는 기술이다.
위의 코드는 모든 정수의 총합을 구하는 메서드로, int는 충분히 크지 않으니 long을 사용해 계산하고 있다.  
하지만, 이 경우 sum 변수를 long이 아닌 Long으로 선언해서 불필요한 Long 인스턴스가 약 2^31개나 만들어지게 된다.
**박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의해야 한다.**

하지만, 방어적 복사를 다루는 아이템 50(새로운 객체를 만들어야 한다면 기존 객체를 재사용하지 마라)과 주의해야 한다.
**방어적 복사가 필요한 상황에서 객체를 재사용했을 때의 피해가, 필요 없는 객체를 반복 생성했을 때의 피해보다 훨씬 크다.**
불필요한 객체 생성은 그저 코드의 가독성과 성능에만 영향을 주지만,
방어적 복사에 실패하면 언제 터져 나올지 모르는 버그와 보안 구멍으로 이어지기 때문이다.
