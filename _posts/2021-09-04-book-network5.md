---
layout: post
title: Book/성공과 실패를 결정하는 1% 네트워크 원리/6장
date: 2021-09-04
excerpt: "성공과 실패를 결정하는 1% 네트워크 원리 - 6장 웹 서버에 도착하여 응답 데이터가 웹 브라우저로 돌아간다"
tags: [csstudy, network, book]
comments: true
---

# 1. 서버의 개요
### 1. 클라이언트와 서버의 차이점
- 클라이언트의 데이터 송수신 동작
    1. 소켓을 만든다 (소켓 작성 단계)
    2. 서버측의 소켓과 파이프로 연결한다 (접속 단계)
    3. 데이터를 송수신한다 (송수신 단계)
    4. 파이프를 분리하고 소켓을 말소한다 (연결 끊기 단계)
- 서버의 데이터 송수신 동작
    1. 소켓을 만든다 (소켓 작성 단계)
    2. 소켓을 접속 대기 상태로 만든다 (접속 대기 상태)
    3. 접속을 접수한다 (접속 접수 단계)
    4. 데이터를 송수신한다 (송수신 단계)
    5. 파이프를 분리하고 소켓을 말소한다 (연결 끊기 단계)

### 2. 서버측의 소켓과 포트번호
- 서버측은 접속 동작을 할 때 **잇달아 복사하여 새 소켓을 만듦**
    - 접속 대기 상태의 소켓을 사용하는 것이 아니라 접속 대기의 소켓을 복사하여 새 소켓을 만들고 새 소켓을 클라이언트 측의 소켓과 접속한 후 원래 소켓은 그대로 접속 대기 상태인 채로 둠
    - 클라이언트가 접속 시 접속 대기 상태의 소켓이 없으면 곤란해지기 때문
- 새 소켓을 만들 때는 **접속 대기 상태의 소켓의 포트번호와 동일하게 할당**
    - 클라이언트에서 80번이라는 포트번호의 소켓에 접속을 보냈는데 다른 포트 번호의 소켓으로부터 회답이 돌아오면 안 되기 때문
    - 이렇게 되면 같은 포트번호를 가진 여러 개의 소켓을 TCP 헤더에 있는 수신처 포트번호만 가지고 구분할 수 없기 때문에 소켓을 지정할 때 클라이언트측의 IP주소, 포트번호, 서버측의 IP주소, 포트번호를 모두 사용

# 2. 서버의 수신 동작
### 1. MAC 부분
- 서버에 패킷이 도착하면 먼저 프레임 체크 시퀀스(FCS)를 통해 **오류 유무 검사**
- 그 다음 맨 앞의 MAC 헤더에 있는 수신처 MAC주소를 조사하여 패킷이 **자신을 수신처로 하여 보낸 것인지 판단**
    - 수신처가 자신으로 되어있는 패킷만 남기고 나머지는 버림
- LAN 드라이버가 CPU 인터럽트를 호출하여 **프로토콜 스택에 패킷을 건네줌**

### 2. IP 부분
- IP 담당 부분이 IP 헤더의 내용이 **규칙에 따라 올바르게 만들어졌는지 검사**한 후 **수신처 IP 주소가 자신을 대상으로 하는지 조사**
    - 수신처가 자신이 아니라면 경로표에서 중계 대상을 조사해 패킷 중계
- 그 다음 패킷이 분할되었는지를 조사하고 분할된 경우 모든 조각이 전부 도착할 때까지 일시적으로 메모리에 저장해둠
- 모든 조각이 도착하면 패킷의 **조각을 조립하여 원래의 패킷으로 복원**
- 그 다음 IP 헤더의 프로토콜 번호를 통해 해당하는 **담당 부분(TCP or UDP)에 패킷을 건네줌**

### 3. TCP 부분
1. 접속 동작의 패킷이 도착한 경우
    - 패킷의 TCP 헤더에 있는 SYN이 1로 되어있으면 접속 동작 패킷으로 판단
    - 도착한 패킷의 수신처 포트 번호를 조사하여 같은 번호의 **접속 대기 상태 소켓이 있는지 확인** 후 접속을 접수하는 동작 실행  (접속 대기 소켓이 없으면 오류 통지 패킷 반송)
    - 접속 대기 소켓을 복사하여 새 소켓을 만들고 송신처 IP 주소, 포트 번호, 시퀀스 번호의 초기값, 윈도우 값 등 필요 정보를 기록 후 패킷을 받았음을 나타내는 ACK 번호와 수신처의 시퀀스 번호의 초기값, 윈도우 값 등을 기록한 **TCP 헤더를 만들어 클라이언트에 반송**
2. 데이터 패킷이 도착한 경우
    - 도착한 패킷이 **어느 소켓에 해당하는지 조사** (IP 헤더의 송신처/수신처 IP주소, TCP 헤더의 송신처/수신처 포트번호를 참고)
    - 해당 소켓을 발견하면 패킷에 기록되어 있는 데이터 송수신 진행상황과 도착한 패킷의 TCP 헤더의 정보를 결합하여 **데이터 송수신 동작이 올바르게 진행되고 있는지 점검**
    - 그 후 패킷에서 데이터 조각을 추출하여 수신 버퍼에 저장하는 방식으로 **데이터를 분할하기 전의 상태로 되돌림**
    - 마지막으로 수신 패킷의 시퀀스 번호와 데이터 조각의 길이로부터 **ACK을 계산해 TCP 헤더에 기록한 후 클라이언트에 반송**

# 3. 웹 서버 소프트웨어가 리퀘스트 메시지의 의미를 해석하여 요구에 응한다
### 1. HTTP 리퀘스트 메시지
- HTTP 리퀘스트 메시지의 첫 줄에 있는 RequestLine을 읽어 내부의 동작을 판단
- 웹 서버는 URI에 쓰여있는 파일명을 조사하여 이것이 프로그램인지 판단 (.cgi, .php 등)
    - 프로그램이라면 리퀘스트 메시지에서 추출한 데이터와 함께 OS에 작동을 의뢰함
    - 작동한 프로그램이 무언가의 출력 데이터를 웹 서버에 돌려줌
    - 웹 서버는 이것을 그대로 응답 메시지로 클라이언트에 반송

### 2. 액세스 제어
- **액세스 제어** : 동작을 실행할 때 사전에 설정해 둔 조건에 해당하는지 조사하고, 조건에 해당하는 경우만 동작을 실행하게 하는 기능 (ex. 관리자 기능)
- 웹 서버에서 설정하는 조건
    1. 클라이언트의 주소 : 접속 시 클라이언트의 IP 주소를 점검
    2. 클라이언트의 도메인명 : 클라이언트의 IP 주소에서 DNS 서버를 이용해 도메인명 조사
    3. 사용자명과 패스워드

# 4. 웹 브라우저가 응답 메시지를 받아 화면에 표시한다
### HTTP Response Message
- 먼저 응답 메시지에 저장된 데이터가 어떤 종류인지를 조사 `Content-Type`
- 데이터의 종류에 따라 화면 표시 프로그램을 호출하여 데이터 표시
    - 데이터의 종류에 따라 호출할 프로그램을 결정하여 데이터를 건네면 화면에 호출한 프로그램이 표시됨
